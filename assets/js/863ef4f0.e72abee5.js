"use strict";(self.webpackChunkverkle_dev=self.webpackChunkverkle_dev||[]).push([[592],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>m});var o=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function a(t,e){if(null==t)return{};var n,o,r=function(t,e){if(null==t)return{};var n,o,r={},i=Object.keys(t);for(o=0;o<i.length;o++)n=i[o],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(o=0;o<i.length;o++)n=i[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var p=o.createContext({}),$=function(t){var e=o.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},u=function(t){var e=$(t.components);return o.createElement(p.Provider,{value:e},t.children)},c={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},s=o.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,p=t.parentName,u=a(t,["components","mdxType","originalType","parentName"]),s=$(n),m=r,g=s["".concat(p,".").concat(m)]||s[m]||c[m]||i;return n?o.createElement(g,l(l({ref:e},u),{},{components:n})):o.createElement(g,l({ref:e},u))}));function m(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=s;var a={};for(var p in e)hasOwnProperty.call(e,p)&&(a[p]=e[p]);a.originalType=t,a.mdxType="string"==typeof t?t:r,l[1]=a;for(var $=2;$<i;$++)l[$]=n[$];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}s.displayName="MDXCreateElement"},2602:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>$});var o=n(7462),r=(n(7294),n(3905));const i={},l="IPA Multipoint",a={unversionedId:"Theory/multipoint",id:"Theory/multipoint",title:"IPA Multipoint",description:"Introduction",source:"@site/docs/Theory/multipoint.md",sourceDirName:"Theory",slug:"/Theory/multipoint",permalink:"/docs/Theory/multipoint",draft:!1,editUrl:"https://github.com/ethereum/verkle-dev-website/blob/master/docs/Theory/multipoint.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dividing In Lagrange basis when one of the points is zero - Generalised",permalink:"/docs/Theory/dividing_on_zero"},next:{title:"Theory",permalink:"/docs/Theory/summary"}},p={},$=[{value:"Introduction",id:"introduction",level:2},{value:"Statement",id:"statement",level:2},{value:"Proof",id:"proof",level:2},{value:"Verification",id:"verification",level:2},{value:"Computing $g(t)$",id:"computing-gt",level:3},{value:"Computing $g_1(X)$",id:"computing-g_1x",level:4},{value:"Is $g(t)$ correct?",id:"is-gt-correct",level:4},{value:"Verify $g(x)$ at $t$",id:"verify-gx-at-t",level:2},{value:"Complexity",id:"complexity",level:2},{value:"Aggregation",id:"aggregation",level:2},{value:"Prover",id:"prover",level:2},{value:"Verifier",id:"verifier",level:2},{value:"Complexity",id:"complexity-1",level:2},{value:"Do we need to add $g_1(X)$ to the transcript?",id:"do-we-need-to-add-g_1x-to-the-transcript",level:2}],u={toc:$};function c(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"ipa-multipoint"},"IPA Multipoint"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This document explains how to open multiple polynomials at multiple different points. Ultimately, we use one IPA proof, 1 commitment and 1 scalar. This is the batched setting."),(0,r.kt)("h2",{id:"statement"},"Statement"),(0,r.kt)("p",null,"Given $m$ IPA commitments $C",(0,r.kt)("em",{parentName:"p"},"0 = ","[f_0(X)]"," ... C"),"{m-1} = ","[f_{m-1}(X)]","$, prove evaluations:"),(0,r.kt)("p",null,"$$\nf",(0,r.kt)("em",{parentName:"p"},"0(z_0) = y_0 ","\\","\\vdots ","\\","f"),"{m-1}(z",(0,r.kt)("em",{parentName:"p"},"{m-1}) = y"),"{m-1}\n$$"),(0,r.kt)("p",null,"where $z_i \\in ","{","0,...,d-1","}","$"),(0,r.kt)("h2",{id:"proof"},"Proof"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Let $r \\leftarrow H(C",(0,r.kt)("em",{parentName:"li"},"0,...C"),"{m-1}, z",(0,r.kt)("em",{parentName:"li"},"0, ..., z"),"{m-1}, y",(0,r.kt)("em",{parentName:"li"},"0, ..., y"),"{m-1})$")),(0,r.kt)("p",null,"$$\ng(X) =  r^0 \\frac{f",(0,r.kt)("em",{parentName:"p"},"0(X) - y_0}{X-z_0} + r^1 \\frac{f_1(X) - y_1}{X-z_1} + \\ldots +r^{m-1} \\frac{f"),"{m-1}(X) - y",(0,r.kt)("em",{parentName:"p"},"{m-1}}{X-z"),"{m-1}}\n$$"),(0,r.kt)("p",null,"The prover starts off by committing to $g(X)$, we denote this by $D$ or $","[g(X)]","$."),(0,r.kt)("p",null,"The provers job is to now convince the verifier that $D$ is a commitment to $g(X)$. We do this by evaluating $g(X)$ at some random point $t$"),(0,r.kt)("p",null,"We split the evaluation into two parts $g_1(t)$ and $g_2(t)$, $g_2(t)$ can be computed by the verifier, while $g_1(t)$ cannot, because it involves random evaluations at the polynomials $f_i(X)$. "),(0,r.kt)("blockquote",null,(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"The verifier is able to compute the $g_2(t)$."),(0,r.kt)("li",{parentName:"ul"},"The prover will compute $g_1(t)$ and send a proof of it's correctness."))),(0,r.kt)("p",null,"$$\ng_1(t) = r^i \\frac{f_i(t)}{t-z_i}\n$$"),(0,r.kt)("p",null,"$$\ng_2(t) = r^i \\frac{y_i}{t-z_i}\n$$"),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Let $t \\leftarrow H(r,D)$")),(0,r.kt)("p",null,"We note that $g_1(X) = r^i \\frac{f_i(X)}{X-z_i}$, however, we specify it as $r^i \\frac{f_i(X)}{t-z_i}$ because the latter is also able to prove an opening for $g_1(t)$ ",(0,r.kt)("strong",{parentName:"p"},"and")," the verifier is able to compute the commitment for it."),(0,r.kt)("p",null,"Now we form two IPA proofs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One for $g_1(X)$ at $t$. We call this $\\pi$ "),(0,r.kt)("li",{parentName:"ul"},"One for $g(X)$ at $t$. We call this $\\rho$")),(0,r.kt)("p",null,"The prover now computes $y = g_1(t)$"),(0,r.kt)("p",null,"The proof consists of $D, (\\pi, y), \\rho$"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In this non-aggregated variation, the prover does not need to add $","[g_1(X)]","$ to the transcript.")),(0,r.kt)("h2",{id:"verification"},"Verification"),(0,r.kt)("p",null,"The Verifier ultimately wants to verify that $D$ is the commitment to the polynomial $g(x)$."),(0,r.kt)("p",null,"The verifier computes $r$ and $t$."),(0,r.kt)("p",null,"The verifier also computes $g_2(t)$, we mentioned above that they can do this by themselves."),(0,r.kt)("h3",{id:"computing-gt"},"Computing $g(t)$"),(0,r.kt)("p",null,"The verifier now needs to compute $g(t)$:"),(0,r.kt)("p",null,"$g(t) = g_1(t) - g_2(t)$"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We know that $g_1(t)$ was supplied in the proof as $y$. "),(0,r.kt)("li",{parentName:"ul"},"$g_2(t)$ can be computed by the verifier.")),(0,r.kt)("p",null,"Hence the verifier can compute $g(t)$. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note however, that they cannot be sure that $g_1(t)$ is the correct computation by the prover. They need to build $","[g_1(X)]","$ themselves and verify it against $g_1(t)$")),(0,r.kt)("h4",{id:"computing-g_1x"},"Computing $","[g_1(X)]","$"),(0,r.kt)("p",null,"This is $g_1(X)$:"),(0,r.kt)("p",null,"$$\ng_1(X) = r^i \\frac{f_i(X)}{t-z_i}\n$$"),(0,r.kt)("p",null,"Hence $","[g_1(X)]","$ is:"),(0,r.kt)("p",null,"$$\n","[g_1(X)]"," = \\frac{r_i}{t-z_i}C_i\n$$"),(0,r.kt)("p",null,"The verifier is able to compute this themselves, and so is able to verify that $g_1(t)$ was computed correctly using IPA_VERIFY."),(0,r.kt)("p",null,"We can now call IPA_VERIFY using"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"$","[g_1(X)]","$ "),(0,r.kt)("li",{parentName:"ul"},"$g_1(t)$"),(0,r.kt)("li",{parentName:"ul"},"$\\pi$")),(0,r.kt)("h4",{id:"is-gt-correct"},"Is $g(t)$ correct?"),(0,r.kt)("p",null,"Note now that since $g_1(t)$ was verified to be correct and $g_2(t)$ was computed by the verifier, we can be sure that $g(t)$ is correct."),(0,r.kt)("h2",{id:"verify-gx-at-t"},"Verify $g(x)$ at $t$"),(0,r.kt)("p",null,"We now call IPA_VERIFY using:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"$D = ","[g(X)]","$ *"),(0,r.kt)("li",{parentName:"ul"},"$g(t)$"),(0,r.kt)("li",{parentName:"ul"},"$\\rho$")),(0,r.kt)("p",null,"*In actuality, it's not $D$ but an augmented $D$, but  this works at a higher level and does not ruin the explanation."),(0,r.kt)("h2",{id:"complexity"},"Complexity"),(0,r.kt)("p",null,"The communication complexity of this protocol is two IPA proofs, 1 scalar and 1 commitment. We can get a better protocol by aggregating things together!"),(0,r.kt)("h2",{id:"aggregation"},"Aggregation"),(0,r.kt)("p",null,"We now present a protocol to aggregate the two IPA proofs together, only requiring one IPA proof."),(0,r.kt)("h2",{id:"prover"},"Prover"),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Let $q \\leftarrow H(t, ","[g_1(X)]",")$")),(0,r.kt)("p",null,"The prover no longer computes an IPA proof for $g_1(X)$ and $g(X)$ instead they combine them using $q$."),(0,r.kt)("p",null,"$g_3(X) = g_1(X) + q \\cdot g(X)$"),(0,r.kt)("p",null,"Now we form an IPA Proof for $g_3(X)$ at $t$. Lets call this $\\sigma$."),(0,r.kt)("p",null,"The prover still computes $y = g_1(t)$"),(0,r.kt)("p",null,"The proof consists of $D, \\sigma, y$"),(0,r.kt)("h2",{id:"verifier"},"Verifier"),(0,r.kt)("p",null,"In the previous step, the verifier called $","[g_1(X)]","$ ,$g_1(t)$ with $\\pi$, we delay this verification and instead compute:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"$","[g_3(X)]"," = ","[g_1(X)]"," + q \\cdot ","[g(X)]","$"),(0,r.kt)("li",{parentName:"ul"},"$g_3(t) = g_1(t) + q \\cdot g(t)$")),(0,r.kt)("p",null,"We now call IPA_VERIFY using:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"$","[g_3(X)]","$ "),(0,r.kt)("li",{parentName:"ul"},"$g_3(t)$"),(0,r.kt)("li",{parentName:"ul"},"$\\sigma$")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"With overwhelming probability over $q$ this will only return true iff $","[g_1(X)]","$ and $","[g(X)]","$ opened at $t$ are $g_1(t)$ and $g(t)$ respectively, from the equation.")),(0,r.kt)("h2",{id:"complexity-1"},"Complexity"),(0,r.kt)("p",null,"The communication complexity of the protocol is 1 IPA Proof, 1 commitment and 1 scalar."),(0,r.kt)("h2",{id:"do-we-need-to-add-g_1x-to-the-transcript"},"Do we need to add $","[g_1(X)]","$ to the transcript?"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In the KZG document, this is $h(X)$")),(0,r.kt)("p",null,"If we were able to avoid this, then we could save a lot on prover time, as they could evaluate each $f_i$ at $t$, then do $\\frac{r^i \\cdot f_i(t)}{t - z_i}$ instead of needing to first compute $\\frac{r^i \\cdot f_i(X)}{t - z_i}$. (In the non-batched version)"),(0,r.kt)("p",null,"However, we do need to do this because the challenge $q$ is aggregating $","[g_1(X)]","$ and $","[g(X)]","$, we need to bind $","[g_1(X)]","$ to the challenge $q$."),(0,r.kt)("p",null,"There may be an argument to say that since $g_1(X)$ uses $t$ and simply using $q = H(t)$ is enough to bind $g_1(X)$ to $q$. We can restate this problem as:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Given two polynomials : $f(X, Y)$ and $g(X)$ "),(0,r.kt)("p",{parentName:"blockquote"},"I generate a completely random variable $t$."),(0,r.kt)("p",{parentName:"blockquote"},"If I want to add together $f(X, t)$ and $g(x)$"),(0,r.kt)("p",{parentName:"blockquote"},"Is it enough to generate randomness based on $g(X)$ and $t$ alone?")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The answer is no because the prover has free reign over $X$ and can change it without affecting $q$")))}c.isMDXComponent=!0}}]);